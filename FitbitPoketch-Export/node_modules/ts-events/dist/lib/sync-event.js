// Copyright Â© 2015 Rogier Schouten<github@workingcode.ninja>
// License: ISC
'use strict';
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var base_event_1 = require("./base-event");
/**
 * This is a true EventEmitter replacement: the handlers are called synchronously when
 * you post the event.
 * - Allows better error handling by aggregating any errors thrown by handlers.
 * - Prevents livelock by throwing an error when recursion depth is above a maximum.
 * - Handlers are called only for events posted after they were attached.
 * - Handlers are not called anymore when they are detached, even if a post() is in progress
 */
var SyncEvent = /** @class */ (function (_super) {
    __extends(SyncEvent, _super);
    function SyncEvent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * Recursive post() invocations
         */
        _this._recursion = 0;
        return _this;
    }
    Object.defineProperty(SyncEvent.prototype, "evtListenersChanged", {
        /**
         * Sent when someone attaches or detaches
         */
        get: function () {
            if (!this._listenersChanged) {
                // need to delay-load to avoid stack overflow in constructor
                this._listenersChanged = new VoidSyncEvent();
            }
            return this._listenersChanged;
        },
        enumerable: true,
        configurable: true
    });
    SyncEvent.prototype.post = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (!this._listeners || this._listeners.length === 0) {
            return;
        }
        this._recursion++;
        if (typeof SyncEvent.MAX_RECURSION_DEPTH === 'number'
            && Number.isInteger(SyncEvent.MAX_RECURSION_DEPTH)
            && SyncEvent.MAX_RECURSION_DEPTH > 0
            && this._recursion > SyncEvent.MAX_RECURSION_DEPTH) {
            throw new Error('event fired recursively');
        }
        // copy a reference to the array because this._listeners might be replaced during
        // the handler calls
        var listeners = this._listeners;
        for (var i = 0; i < listeners.length; ++i) {
            var listener = listeners[i];
            this._call(listener, args);
        }
        this._recursion--;
    };
    /** @inheritdoc */
    SyncEvent.prototype._attach = function (a, b, once) {
        var _a, _b, _c, _d;
        var count = (_b = (_a = this._listeners) === null || _a === void 0 ? void 0 : _a.length, (_b !== null && _b !== void 0 ? _b : 0));
        var result = _super.prototype._attach.call(this, a, b, once);
        if (this.evtListenersChanged && count !== (_d = (_c = this._listeners) === null || _c === void 0 ? void 0 : _c.length, (_d !== null && _d !== void 0 ? _d : 0))) {
            this.evtListenersChanged.post();
        }
        return result;
    };
    /** @inheritdoc */
    SyncEvent.prototype._detach = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var _a, _b, _c, _d;
        var count = (_b = (_a = this._listeners) === null || _a === void 0 ? void 0 : _a.length, (_b !== null && _b !== void 0 ? _b : 0));
        var result = _super.prototype._detach.apply(this, args);
        if (this.evtListenersChanged && count !== (_d = (_c = this._listeners) === null || _c === void 0 ? void 0 : _c.length, (_d !== null && _d !== void 0 ? _d : 0))) {
            this.evtListenersChanged.post();
        }
        return result;
    };
    /**
     * Maximum number of times that an event handler may cause the same event
     * recursively.
     */
    SyncEvent.MAX_RECURSION_DEPTH = 10;
    return SyncEvent;
}(base_event_1.BaseEvent));
exports.SyncEvent = SyncEvent;
/**
 * Convenience class for events without data
 */
var VoidSyncEvent = /** @class */ (function (_super) {
    __extends(VoidSyncEvent, _super);
    function VoidSyncEvent() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Send the event.
     */
    VoidSyncEvent.prototype.post = function () {
        _super.prototype.post.call(this, undefined);
    };
    return VoidSyncEvent;
}(SyncEvent));
exports.VoidSyncEvent = VoidSyncEvent;
/**
 * Similar to 'error' event on EventEmitter: throws when a post() occurs while no handlers set.
 */
var ErrorSyncEvent = /** @class */ (function (_super) {
    __extends(ErrorSyncEvent, _super);
    function ErrorSyncEvent() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ErrorSyncEvent.prototype.post = function (data) {
        if (this.listenerCount() === 0) {
            throw new Error("error event posted while no listeners attached. Error: " + data.message);
        }
        _super.prototype.post.call(this, data);
    };
    return ErrorSyncEvent;
}(SyncEvent));
exports.ErrorSyncEvent = ErrorSyncEvent;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3luYy1ldmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvc3luYy1ldmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSw2REFBNkQ7QUFDN0QsZUFBZTtBQUVmLFlBQVksQ0FBQzs7Ozs7Ozs7Ozs7Ozs7O0FBRWIsMkNBQWlEO0FBRWpEOzs7Ozs7O0dBT0c7QUFDSDtJQUFrQyw2QkFBWTtJQUE5QztRQUFBLHFFQTRFQztRQXJERzs7V0FFRztRQUNLLGdCQUFVLEdBQVcsQ0FBQyxDQUFDOztJQWtEbkMsQ0FBQztJQXhFRyxzQkFBVywwQ0FBbUI7UUFIOUI7O1dBRUc7YUFDSDtZQUNJLElBQUksQ0FBQyxJQUFJLENBQUMsaUJBQWlCLEVBQUU7Z0JBQ3pCLDREQUE0RDtnQkFDNUQsSUFBSSxDQUFDLGlCQUFpQixHQUFHLElBQUksYUFBYSxFQUFFLENBQUM7YUFDaEQ7WUFDRCxPQUFPLElBQUksQ0FBQyxpQkFBaUIsQ0FBQztRQUNsQyxDQUFDOzs7T0FBQTtJQXdCTSx3QkFBSSxHQUFYO1FBQVksY0FBYzthQUFkLFVBQWMsRUFBZCxxQkFBYyxFQUFkLElBQWM7WUFBZCx5QkFBYzs7UUFDdEIsSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLElBQUksSUFBSSxDQUFDLFVBQVUsQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO1lBQ2xELE9BQU87U0FDVjtRQUNELElBQUksQ0FBQyxVQUFVLEVBQUUsQ0FBQztRQUNsQixJQUNJLE9BQU8sU0FBUyxDQUFDLG1CQUFtQixLQUFLLFFBQVE7ZUFDOUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxTQUFTLENBQUMsbUJBQW1CLENBQUM7ZUFDL0MsU0FBUyxDQUFDLG1CQUFtQixHQUFHLENBQUM7ZUFDakMsSUFBSSxDQUFDLFVBQVUsR0FBRyxTQUFTLENBQUMsbUJBQW1CLEVBQ3BEO1lBQ0UsTUFBTSxJQUFJLEtBQUssQ0FBQyx5QkFBeUIsQ0FBQyxDQUFDO1NBQzlDO1FBQ0QsaUZBQWlGO1FBQ2pGLG9CQUFvQjtRQUNwQixJQUFNLFNBQVMsR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDO1FBQ2xDLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxTQUFTLENBQUMsTUFBTSxFQUFFLEVBQUUsQ0FBQyxFQUFFO1lBQ3ZDLElBQU0sUUFBUSxHQUFHLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUM5QixJQUFJLENBQUMsS0FBSyxDQUFDLFFBQVEsRUFBRSxJQUFJLENBQUMsQ0FBQztTQUM5QjtRQUNELElBQUksQ0FBQyxVQUFVLEVBQUUsQ0FBQztJQUN0QixDQUFDO0lBRUQsa0JBQWtCO0lBQ1IsMkJBQU8sR0FBakIsVUFBa0IsQ0FBNkMsRUFBRSxDQUFrQyxFQUFFLElBQWE7O1FBQzlHLElBQU0sS0FBSyxlQUFHLElBQUksQ0FBQyxVQUFVLDBDQUFFLE1BQU0sdUNBQUksQ0FBQyxFQUFBLENBQUM7UUFDM0MsSUFBTSxNQUFNLEdBQUcsaUJBQU0sT0FBTyxZQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFDekMsSUFBSSxJQUFJLENBQUMsbUJBQW1CLElBQUksS0FBSyxLQUFLLFlBQUMsSUFBSSxDQUFDLFVBQVUsMENBQUUsTUFBTSx1Q0FBSSxDQUFDLEVBQUMsRUFBRTtZQUN0RSxJQUFJLENBQUMsbUJBQW1CLENBQUMsSUFBSSxFQUFFLENBQUM7U0FDbkM7UUFDRCxPQUFPLE1BQU0sQ0FBQztJQUNsQixDQUFDO0lBRUQsa0JBQWtCO0lBQ1IsMkJBQU8sR0FBakI7UUFBa0IsY0FBYzthQUFkLFVBQWMsRUFBZCxxQkFBYyxFQUFkLElBQWM7WUFBZCx5QkFBYzs7O1FBQzVCLElBQU0sS0FBSyxlQUFHLElBQUksQ0FBQyxVQUFVLDBDQUFFLE1BQU0sdUNBQUksQ0FBQyxFQUFBLENBQUM7UUFDM0MsSUFBTSxNQUFNLEdBQUcsaUJBQU0sT0FBTyxhQUFJLElBQUksQ0FBQyxDQUFDO1FBQ3RDLElBQUksSUFBSSxDQUFDLG1CQUFtQixJQUFJLEtBQUssS0FBSyxZQUFDLElBQUksQ0FBQyxVQUFVLDBDQUFFLE1BQU0sdUNBQUksQ0FBQyxFQUFDLEVBQUU7WUFDdEUsSUFBSSxDQUFDLG1CQUFtQixDQUFDLElBQUksRUFBRSxDQUFDO1NBQ25DO1FBQ0QsT0FBTyxNQUFNLENBQUM7SUFDbEIsQ0FBQztJQTFERDs7O09BR0c7SUFDVyw2QkFBbUIsR0FBbUIsRUFBRSxDQUFDO0lBdUQzRCxnQkFBQztDQUFBLEFBNUVELENBQWtDLHNCQUFTLEdBNEUxQztBQTVFWSw4QkFBUztBQThFdEI7O0dBRUc7QUFDSDtJQUFtQyxpQ0FBZTtJQUFsRDs7SUFRQSxDQUFDO0lBTkc7O09BRUc7SUFDSSw0QkFBSSxHQUFYO1FBQ0ksaUJBQU0sSUFBSSxZQUFDLFNBQVMsQ0FBQyxDQUFDO0lBQzFCLENBQUM7SUFDTCxvQkFBQztBQUFELENBQUMsQUFSRCxDQUFtQyxTQUFTLEdBUTNDO0FBUlksc0NBQWE7QUFVMUI7O0dBRUc7QUFDSDtJQUFvQyxrQ0FBZ0I7SUFBcEQ7O0lBUUEsQ0FBQztJQU5VLDZCQUFJLEdBQVgsVUFBWSxJQUFXO1FBQ25CLElBQUksSUFBSSxDQUFDLGFBQWEsRUFBRSxLQUFLLENBQUMsRUFBRTtZQUM1QixNQUFNLElBQUksS0FBSyxDQUFDLDREQUEwRCxJQUFJLENBQUMsT0FBUyxDQUFDLENBQUM7U0FDN0Y7UUFDRCxpQkFBTSxJQUFJLFlBQUMsSUFBSSxDQUFDLENBQUM7SUFDckIsQ0FBQztJQUNMLHFCQUFDO0FBQUQsQ0FBQyxBQVJELENBQW9DLFNBQVMsR0FRNUM7QUFSWSx3Q0FBYyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCDCqSAyMDE1IFJvZ2llciBTY2hvdXRlbjxnaXRodWJAd29ya2luZ2NvZGUubmluamE+XHJcbi8vIExpY2Vuc2U6IElTQ1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuaW1wb3J0IHtCYXNlRXZlbnQsIFBvc3RhYmxlfSBmcm9tICcuL2Jhc2UtZXZlbnQnO1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgaXMgYSB0cnVlIEV2ZW50RW1pdHRlciByZXBsYWNlbWVudDogdGhlIGhhbmRsZXJzIGFyZSBjYWxsZWQgc3luY2hyb25vdXNseSB3aGVuXHJcbiAqIHlvdSBwb3N0IHRoZSBldmVudC5cclxuICogLSBBbGxvd3MgYmV0dGVyIGVycm9yIGhhbmRsaW5nIGJ5IGFnZ3JlZ2F0aW5nIGFueSBlcnJvcnMgdGhyb3duIGJ5IGhhbmRsZXJzLlxyXG4gKiAtIFByZXZlbnRzIGxpdmVsb2NrIGJ5IHRocm93aW5nIGFuIGVycm9yIHdoZW4gcmVjdXJzaW9uIGRlcHRoIGlzIGFib3ZlIGEgbWF4aW11bS5cclxuICogLSBIYW5kbGVycyBhcmUgY2FsbGVkIG9ubHkgZm9yIGV2ZW50cyBwb3N0ZWQgYWZ0ZXIgdGhleSB3ZXJlIGF0dGFjaGVkLlxyXG4gKiAtIEhhbmRsZXJzIGFyZSBub3QgY2FsbGVkIGFueW1vcmUgd2hlbiB0aGV5IGFyZSBkZXRhY2hlZCwgZXZlbiBpZiBhIHBvc3QoKSBpcyBpbiBwcm9ncmVzc1xyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFN5bmNFdmVudDxUPiBleHRlbmRzIEJhc2VFdmVudDxUPiBpbXBsZW1lbnRzIFBvc3RhYmxlPFQ+IHtcclxuICAgIC8qKlxyXG4gICAgICogU2VudCB3aGVuIHNvbWVvbmUgYXR0YWNoZXMgb3IgZGV0YWNoZXNcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBldnRMaXN0ZW5lcnNDaGFuZ2VkKCk6IFZvaWRTeW5jRXZlbnQge1xyXG4gICAgICAgIGlmICghdGhpcy5fbGlzdGVuZXJzQ2hhbmdlZCkge1xyXG4gICAgICAgICAgICAvLyBuZWVkIHRvIGRlbGF5LWxvYWQgdG8gYXZvaWQgc3RhY2sgb3ZlcmZsb3cgaW4gY29uc3RydWN0b3JcclxuICAgICAgICAgICAgdGhpcy5fbGlzdGVuZXJzQ2hhbmdlZCA9IG5ldyBWb2lkU3luY0V2ZW50KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9saXN0ZW5lcnNDaGFuZ2VkO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRXZlbnQgZm9yIGxpc3RlbmluZyB0byBsaXN0ZW5lciBjb3VudFxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIF9saXN0ZW5lcnNDaGFuZ2VkPzogVm9pZFN5bmNFdmVudDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE1heGltdW0gbnVtYmVyIG9mIHRpbWVzIHRoYXQgYW4gZXZlbnQgaGFuZGxlciBtYXkgY2F1c2UgdGhlIHNhbWUgZXZlbnRcclxuICAgICAqIHJlY3Vyc2l2ZWx5LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIE1BWF9SRUNVUlNJT05fREVQVEg/OiBudW1iZXIgfCBudWxsID0gMTA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWN1cnNpdmUgcG9zdCgpIGludm9jYXRpb25zXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgX3JlY3Vyc2lvbjogbnVtYmVyID0gMDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNlbmQgdGhlIGV2ZW50LiBIYW5kbGVycyBhcmUgY2FsbGVkIGltbWVkaWF0ZWx5IGFuZCBzeW5jaHJvbm91c2x5LlxyXG4gICAgICogSWYgYW4gZXJyb3IgaXMgdGhyb3duIGJ5IGEgaGFuZGxlciwgdGhlIHJlbWFpbmluZyBoYW5kbGVycyBhcmUgc3RpbGwgY2FsbGVkLlxyXG4gICAgICogQWZ0ZXJ3YXJkLCBhbiBBZ2dyZWdhdGVFcnJvciBpcyB0aHJvd24gd2l0aCB0aGUgb3JpZ2luYWwgZXJyb3IocykgaW4gaXRzICdjYXVzZXMnIHByb3BlcnR5LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcG9zdChkYXRhOiBUKTogdm9pZDtcclxuICAgIHB1YmxpYyBwb3N0KC4uLmFyZ3M6IGFueVtdKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9saXN0ZW5lcnMgfHwgdGhpcy5fbGlzdGVuZXJzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3JlY3Vyc2lvbisrO1xyXG4gICAgICAgIGlmIChcclxuICAgICAgICAgICAgdHlwZW9mIFN5bmNFdmVudC5NQVhfUkVDVVJTSU9OX0RFUFRIID09PSAnbnVtYmVyJ1xyXG4gICAgICAgICAgICAmJiBOdW1iZXIuaXNJbnRlZ2VyKFN5bmNFdmVudC5NQVhfUkVDVVJTSU9OX0RFUFRIKVxyXG4gICAgICAgICAgICAmJiBTeW5jRXZlbnQuTUFYX1JFQ1VSU0lPTl9ERVBUSCA+IDBcclxuICAgICAgICAgICAgJiYgdGhpcy5fcmVjdXJzaW9uID4gU3luY0V2ZW50Lk1BWF9SRUNVUlNJT05fREVQVEhcclxuICAgICAgICApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdldmVudCBmaXJlZCByZWN1cnNpdmVseScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjb3B5IGEgcmVmZXJlbmNlIHRvIHRoZSBhcnJheSBiZWNhdXNlIHRoaXMuX2xpc3RlbmVycyBtaWdodCBiZSByZXBsYWNlZCBkdXJpbmdcclxuICAgICAgICAvLyB0aGUgaGFuZGxlciBjYWxsc1xyXG4gICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICBjb25zdCBsaXN0ZW5lciA9IGxpc3RlbmVyc1tpXTtcclxuICAgICAgICAgICAgdGhpcy5fY2FsbChsaXN0ZW5lciwgYXJncyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3JlY3Vyc2lvbi0tO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBAaW5oZXJpdGRvYyAqL1xyXG4gICAgcHJvdGVjdGVkIF9hdHRhY2goYTogKChkYXRhOiBUKSA9PiB2b2lkKSB8IE9iamVjdCB8IFBvc3RhYmxlPFQ+LCBiOiAoKGRhdGE6IFQpID0+IHZvaWQpIHwgdW5kZWZpbmVkLCBvbmNlOiBib29sZWFuKTogKCkgPT4gdm9pZCB7XHJcbiAgICAgICAgY29uc3QgY291bnQgPSB0aGlzLl9saXN0ZW5lcnM/Lmxlbmd0aCA/PyAwO1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHN1cGVyLl9hdHRhY2goYSwgYiwgb25jZSk7XHJcbiAgICAgICAgaWYgKHRoaXMuZXZ0TGlzdGVuZXJzQ2hhbmdlZCAmJiBjb3VudCAhPT0gKHRoaXMuX2xpc3RlbmVycz8ubGVuZ3RoID8/IDApKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXZ0TGlzdGVuZXJzQ2hhbmdlZC5wb3N0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIEBpbmhlcml0ZG9jICovXHJcbiAgICBwcm90ZWN0ZWQgX2RldGFjaCguLi5hcmdzOiBhbnlbXSk6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IGNvdW50ID0gdGhpcy5fbGlzdGVuZXJzPy5sZW5ndGggPz8gMDtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBzdXBlci5fZGV0YWNoKC4uLmFyZ3MpO1xyXG4gICAgICAgIGlmICh0aGlzLmV2dExpc3RlbmVyc0NoYW5nZWQgJiYgY291bnQgIT09ICh0aGlzLl9saXN0ZW5lcnM/Lmxlbmd0aCA/PyAwKSkge1xyXG4gICAgICAgICAgICB0aGlzLmV2dExpc3RlbmVyc0NoYW5nZWQucG9zdCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogQ29udmVuaWVuY2UgY2xhc3MgZm9yIGV2ZW50cyB3aXRob3V0IGRhdGFcclxuICovXHJcbmV4cG9ydCBjbGFzcyBWb2lkU3luY0V2ZW50IGV4dGVuZHMgU3luY0V2ZW50PHZvaWQ+IHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNlbmQgdGhlIGV2ZW50LlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcG9zdCgpOiB2b2lkIHtcclxuICAgICAgICBzdXBlci5wb3N0KHVuZGVmaW5lZCk7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTaW1pbGFyIHRvICdlcnJvcicgZXZlbnQgb24gRXZlbnRFbWl0dGVyOiB0aHJvd3Mgd2hlbiBhIHBvc3QoKSBvY2N1cnMgd2hpbGUgbm8gaGFuZGxlcnMgc2V0LlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEVycm9yU3luY0V2ZW50IGV4dGVuZHMgU3luY0V2ZW50PEVycm9yPiB7XHJcblxyXG4gICAgcHVibGljIHBvc3QoZGF0YTogRXJyb3IpOiB2b2lkIHtcclxuICAgICAgICBpZiAodGhpcy5saXN0ZW5lckNvdW50KCkgPT09IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBlcnJvciBldmVudCBwb3N0ZWQgd2hpbGUgbm8gbGlzdGVuZXJzIGF0dGFjaGVkLiBFcnJvcjogJHtkYXRhLm1lc3NhZ2V9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN1cGVyLnBvc3QoZGF0YSk7XHJcbiAgICB9XHJcbn1cclxuIl19