import { Postable } from './base-event';
import { VoidSyncEvent } from './sync-event';
import { AsyncEventOpts } from './async-event';
import { QueuedEventOpts } from './queued-event';
export declare enum EventType {
    Sync = 0,
    Async = 1,
    Queued = 2
}
export interface AnyEventOpts {
    /**
     * Create evtFirstAttached and evtLastDetached so you can monitor when someone is subscribed
     */
    monitorAttach?: boolean;
}
/**
 * An event that behaves like a Sync/Async/Queued event depending on how
 * you subscribe.
 */
export declare class AnyEvent<T> implements Postable<T> {
    /**
     * Sent when someone attaches or detaches
     */
    get evtListenersChanged(): VoidSyncEvent;
    /**
     * Event for listening to listener count
     */
    private _listenersChanged?;
    /**
     * Triggered whenever someone attaches and nobody was attached.
     * Note: you must call the constructor with monitorAttach set to true to create this event!
     */
    evtFirstAttached: VoidAnyEvent;
    /**
     * Triggered whenever someone detaches and nobody is attached anymore
     * Note: you must call the constructor with monitorAttach set to true to create this event!
     */
    evtLastDetached: VoidAnyEvent;
    /**
     * Underlying event implementations; one for every attach type + opts combination
     */
    private _events;
    constructor(opts?: AnyEventOpts);
    /**
     * Legacy method
     * same as attachSync/attachAsync/attachQueued; based on the given enum
     * @param mode determines whether to attach sync/async/queued
     */
    attach(handler: (data: T) => void, opts?: AsyncEventOpts | QueuedEventOpts): () => void;
    attach(boundTo: Object, handler: (data: T) => void, opts?: AsyncEventOpts | QueuedEventOpts): () => void;
    attach(event: Postable<T>, opts?: AsyncEventOpts | QueuedEventOpts): () => void;
    attach(mode: EventType, handler: (data: T) => void, opts?: AsyncEventOpts | QueuedEventOpts): () => void;
    attach(mode: EventType, boundTo: Object, handler: (data: T) => void, opts?: AsyncEventOpts | QueuedEventOpts): () => void;
    attach(mode: EventType, event: Postable<T>, opts?: AsyncEventOpts | QueuedEventOpts): () => void;
    /**
     * Legacy method
     * same as onceSync/onceAsync/onceQueued; based on the given enum
     * @param mode determines whether to once sync/async/queued
     */
    once(handler: (data: T) => void, opts?: AsyncEventOpts | QueuedEventOpts): () => void;
    once(boundTo: Object, handler: (data: T) => void, opts?: AsyncEventOpts | QueuedEventOpts): () => void;
    once(event: Postable<T>, opts?: AsyncEventOpts | QueuedEventOpts): () => void;
    once(mode: EventType, handler: (data: T) => void, opts?: AsyncEventOpts | QueuedEventOpts): () => void;
    once(mode: EventType, boundTo: Object, handler: (data: T) => void, opts?: AsyncEventOpts | QueuedEventOpts): () => void;
    once(mode: EventType, event: Postable<T>, opts?: AsyncEventOpts | QueuedEventOpts): () => void;
    private _attach;
    attachSync(handler: (data: T) => void): () => void;
    attachSync(boundTo: Object, handler: (data: T) => void): () => void;
    attachSync(event: Postable<T>): () => void;
    onceSync(handler: (data: T) => void): () => void;
    onceSync(boundTo: Object, handler: (data: T) => void): () => void;
    onceSync(event: Postable<T>): () => void;
    attachAsync(handler: (data: T) => void, opts?: AsyncEventOpts): () => void;
    attachAsync(boundTo: Object, handler: (data: T) => void, opts?: AsyncEventOpts): () => void;
    attachAsync(event: Postable<T>, opts?: AsyncEventOpts): () => void;
    onceAsync(handler: (data: T) => void, opts?: AsyncEventOpts): () => void;
    onceAsync(boundTo: Object, handler: (data: T) => void, opts?: AsyncEventOpts): () => void;
    onceAsync(event: Postable<T>, opts?: AsyncEventOpts): () => void;
    attachQueued(handler: (data: T) => void, opts?: QueuedEventOpts): () => void;
    attachQueued(boundTo: Object, handler: (data: T) => void, opts?: QueuedEventOpts): () => void;
    attachQueued(event: Postable<T>, opts?: QueuedEventOpts): () => void;
    onceQueued(handler: (data: T) => void, opts?: QueuedEventOpts): () => void;
    onceQueued(boundTo: Object, handler: (data: T) => void, opts?: QueuedEventOpts): () => void;
    onceQueued(event: Postable<T>, opts?: QueuedEventOpts): () => void;
    detach(handler: (data: T) => void): void;
    detach(boundTo: Object, handler: (data: T) => void): void;
    detach(boundTo: Object): void;
    detach(event: Postable<T>): void;
    detach(): void;
    /**
     * Post an event to all current listeners
     */
    post(data: T): void;
    /**
     * The number of attached listeners
     */
    listenerCount(): number;
}
/**
 * Convenience class for AnyEvents without data
 */
export declare class VoidAnyEvent extends AnyEvent<void> {
    /**
     * Send the AsyncEvent.
     */
    post(): void;
}
/**
 * Similar to 'error' event on EventEmitter: throws when a post() occurs while no handlers set.
 */
export declare class ErrorAnyEvent extends AnyEvent<Error> {
    post(data: Error): void;
}
