/// <reference types="node" />
import { EventEmitter } from 'events';
import * as stream from 'stream';
import * as t from 'io-ts';
import { Peer, TypesafeRequestDispatcher } from '@fitbit/jsonrpc-ts';
import { BulkData, FDBTypes } from '@fitbit/fdb-protocol';
export interface RemoteHostOptions {
    userAgentSuffix?: string;
}
export interface ConsoleMessage {
    timestamp?: Date;
    emittedBy: FDBTypes.AppComponent;
    fromHost?: boolean;
    position?: FDBTypes.Position;
    kind: 'log' | 'info' | 'warn' | 'error';
    message: any[];
}
export interface ConsoleTrace {
    timestamp?: Date;
    emittedBy: FDBTypes.AppComponent;
    stack: FDBTypes.Position[];
    kind: 'trace' | 'assert' | 'exception';
    message: any[];
}
export declare class RemoteHost extends EventEmitter {
    static readonly CAPABILITIES: {
        protocol: {
            maxMessageSize: number;
        };
        console: {
            appLogging: boolean;
        };
        io: {
            write: boolean;
        };
    };
    static readonly USER_AGENT: string;
    dispatcher: TypesafeRequestDispatcher;
    rpc: Peer;
    info: FDBTypes.InitializeResult;
    epoch: Date;
    timeout: number;
    protected bulkDataStreams: BulkData;
    private screenshotReceiver;
    private appContentsListReceiver;
    private heapSnapshotReceiver;
    private serializerTransform;
    protected constructor(timeout: number);
    static connect(hostStream: stream.Duplex, { userAgentSuffix, timeout, postDeserializeTransform, preSerializeTransform, }?: {
        userAgentSuffix?: string | undefined;
        timeout?: number | undefined;
        postDeserializeTransform?: stream.PassThrough | undefined;
        preSerializeTransform?: stream.PassThrough | undefined;
    }): Promise<RemoteHost>;
    convertTimestamp(relativeTS: number): Date;
    handleMessage: (params: FDBTypes.ConsoleMessage) => void;
    handleTrace: (params: FDBTypes.TraceMessage) => void;
    handleAppRunning: (params: FDBTypes.App) => void;
    handleAppClosed: (params: FDBTypes.App) => void;
    hasCapability(path: string): boolean;
    get maxMessageSize(): number;
    protected bindMethod<P extends t.Any, R extends t.Any>(method: string, paramsType: P, resultType: R, { timeoutEnabled, minTimeout, }?: {
        timeoutEnabled?: boolean | undefined;
        minTimeout?: number | undefined;
    }): (params: t.TypeOf<P>) => Promise<t.TypeOf<R>>;
    private initialize;
    ping: () => Promise<void>;
    protected ioWrite: (params: {
        stream: string | number;
        data: string | Buffer;
    } & {
        encoding?: "base64" | "none" | undefined;
    }) => Promise<any>;
    protected beginStreamingInstall: (params: {
        componentBundle: "app" | "companion";
    }) => Promise<{
        stream: string | number;
    }>;
    protected finalizeStreamingInstall: (params: {
        stream: string | number;
    }) => Promise<{
        app: {
            uuid: string;
            buildID: string;
        };
        components: ("app" | "companion" | "settings")[];
    } & {
        installType?: "full" | "partial" | undefined;
    }>;
    protected abortStreamingInstall: (params: {
        stream: string | number;
    }) => Promise<any>;
    launchAppComponent: (params: {
        uuid: string;
        component: "app" | "companion" | "settings";
    } & {
        debugInstrumentation?: boolean | undefined;
    }) => Promise<{
        uuid: string;
        buildID: string;
    } & {
        component: "app" | "companion" | "settings";
    }>;
    private changeSerialization;
    protected writeToStream(stream: FDBTypes.StreamToken, data: Buffer, { onProgress, }?: {
        onProgress?: ((bytesWritten: number, totalBytes: number) => void) | undefined;
    }): Promise<void>;
    installApp(componentBundle: 'app' | 'companion', data: Buffer, { onProgress, }?: {
        onProgress?: ((bytesWritten: number, totalBytes: number) => void) | undefined;
    }): Promise<{
        app: {
            uuid: string;
            buildID: string;
        };
        components: ("app" | "companion" | "settings")[];
        installType: "full" | "partial";
    } | null>;
    protected beginStreamingScreenshotCapture: (params: {
        stream: string | number;
        imageFormat: string;
    }) => Promise<{
        length?: number | undefined;
    }>;
    canTakeScreenshot(): boolean;
    screenshotFormats(): string[];
    takeScreenshot(format: string, onWrite?: (received: number, total?: number) => void): Promise<Buffer>;
    private sendEvalCmd;
    hasEvalSupport(): boolean;
    eval(cmd: string): Promise<{
        success: true;
        value: string;
    } | {
        success: false;
    }>;
    supportsPartialAppInstall(): boolean;
    protected beginStreamingAppComponentContents: (params: {
        uuid: string;
        componentBundle: "app" | "companion";
        stream: string | number;
    }) => Promise<any>;
    getInstalledAppContents(uuid: string, componentBundle: FDBTypes.ComponentBundleKind): Promise<{
        files: {
            [x: string]: {
                sha256: string;
            };
        };
    }>;
    getHeapSnapshotSupport(): {
        supported: boolean;
        requiresInstrumentedLaunch: boolean;
        formats: string[];
    };
    protected beginHeapSnapshotCapture: (params: {
        format: string;
        stream: string | number;
    }) => Promise<any>;
    captureHeapSnapshot(format: string): Promise<Buffer>;
}
//# sourceMappingURL=index.d.ts.map