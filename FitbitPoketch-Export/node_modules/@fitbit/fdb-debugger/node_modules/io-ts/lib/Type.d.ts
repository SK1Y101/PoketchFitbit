/**
 * **This module is experimental**
 *
 * Experimental features are published in order to get early feedback from the community, see these tracking
 * [issues](https://github.com/gcanti/io-ts/issues?q=label%3Av2.2+) for further discussions and enhancements.
 *
 * A feature tagged as _Experimental_ is in a high state of flux, you're at risk of it changing without notice.
 *
 * @since 2.2.3
 */
import * as t from './index'
import { Literal, Schemable1, WithUnion1, WithRefine1, WithUnknownContainers1 } from './Schemable'
/**
 * @category model
 * @since 2.2.3
 */
export interface Type<A> extends t.Type<A, unknown, unknown> {}
/**
 * @category constructors
 * @since 2.2.3
 */
export declare const literal: <A extends readonly [Literal, ...Literal[]]>(...values: A) => Type<A[number]>
/**
 * @category primitives
 * @since 2.2.3
 */
export declare const string: Type<string>
/**
 * @category primitives
 * @since 2.2.3
 */
export declare const number: Type<number>
/**
 * @category primitives
 * @since 2.2.3
 */
export declare const boolean: Type<boolean>
/**
 * @category primitives
 * @since 2.2.3
 */
export declare const UnknownArray: Type<Array<unknown>>
/**
 * @category primitives
 * @since 2.2.3
 */
export declare const UnknownRecord: Type<Record<string, unknown>>
/**
 * @category combinators
 * @since 2.2.3
 */
export declare const refine: <A, B extends A>(refinement: (a: A) => a is B, id: string) => (from: Type<A>) => Type<B>
/**
 * @category combinators
 * @since 2.2.3
 */
export declare const nullable: <A>(or: Type<A>) => Type<A | null>
/**
 * @category combinators
 * @since 2.2.3
 */
export declare const type: <A>(properties: { [K in keyof A]: Type<A[K]> }) => Type<{ [K_1 in keyof A]: A[K_1] }>
/**
 * @category combinators
 * @since 2.2.3
 */
export declare const partial: <A>(
  properties: { [K in keyof A]: Type<A[K]> }
) => Type<Partial<{ [K_1 in keyof A]: A[K_1] }>>
/**
 * @category combinators
 * @since 2.2.3
 */
export declare const record: <A>(codomain: Type<A>) => Type<Record<string, A>>
/**
 * @category combinators
 * @since 2.2.3
 */
export declare const array: <A>(item: Type<A>) => Type<A[]>
/**
 * @category combinators
 * @since 2.2.3
 */
export declare const tuple: <A extends readonly unknown[]>(...components: { [K in keyof A]: Type<A[K]> }) => Type<A>
/**
 * @category combinators
 * @since 2.2.3
 */
export declare const intersect: <B>(right: Type<B>) => <A>(left: Type<A>) => Type<A & B>
/**
 * @category combinators
 * @since 2.2.3
 */
export declare const lazy: <A>(id: string, f: () => Type<A>) => Type<A>
/**
 * @category combinators
 * @since 2.2.3
 */
export declare const sum: <T extends string>(
  _tag: T
) => <A>(members: { [K in keyof A]: Type<A[K]> }) => Type<A[keyof A]>
/**
 * @category combinators
 * @since 2.2.3
 */
export declare const union: <A extends readonly [unknown, ...unknown[]]>(
  ...members: { [K in keyof A]: Type<A[K]> }
) => Type<A[number]>
/**
 * @category instances
 * @since 2.2.3
 */
export declare const URI = 'io-ts/Type'
/**
 * @category instances
 * @since 2.2.3
 */
export declare type URI = typeof URI
declare module 'fp-ts/lib/HKT' {
  interface URItoKind<A> {
    readonly [URI]: Type<A>
  }
}
/**
 * @category instances
 * @since 2.2.8
 */
export declare const Schemable: Schemable1<URI>
/**
 * @category instances
 * @since 2.2.8
 */
export declare const WithUnknownContainers: WithUnknownContainers1<URI>
/**
 * @category instances
 * @since 2.2.8
 */
export declare const WithUnion: WithUnion1<URI>
/**
 * @category instances
 * @since 2.2.8
 */
export declare const WithRefine: WithRefine1<URI>
