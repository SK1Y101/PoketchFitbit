import { PathReporter } from 'io-ts/lib/PathReporter';
import { isRight } from 'fp-ts/lib/Either';
import * as peer from './peer';
var TypesafeRequestDispatcher = (function () {
    function TypesafeRequestDispatcher() {
        var _this = this;
        this.requestHandlers = new Map();
        this.notificationHandlers = new Map();
        this.defaultNotificationHandler = function () { };
        this.onRequest = function (method, params) {
            var handlers = _this.requestHandlers.get(method);
            if (handlers === undefined) {
                throw new peer.MethodNotFound("No such method: '" + method + "'");
            }
            else {
                var validationErrors = [];
                for (var _i = 0, handlers_1 = handlers; _i < handlers_1.length; _i++) {
                    var _a = handlers_1[_i], fn = _a.fn, paramsType = _a.paramsType;
                    var decoded = paramsType.decode(params);
                    if (isRight(decoded)) {
                        return fn(decoded.right);
                    }
                    validationErrors.push(PathReporter.report(decoded));
                }
                throw new peer.InvalidParams("Invalid parameters for method " + method, validationErrors);
            }
        };
        this.onNotification = function (method, params) {
            var handlers = _this.notificationHandlers.get(method);
            if (handlers !== undefined) {
                for (var _i = 0, handlers_2 = handlers; _i < handlers_2.length; _i++) {
                    var _a = handlers_2[_i], fn = _a.fn, paramsType = _a.paramsType;
                    var decoded = paramsType.decode(params);
                    if (isRight(decoded)) {
                        fn(decoded.right);
                        return;
                    }
                }
            }
            _this.defaultNotificationHandler(method, params);
        };
    }
    TypesafeRequestDispatcher.register = function (collection, name, paramsType, impl) {
        if (name.startsWith('rpc.')) {
            throw new TypeError('Method names beginning with "rpc." are reserved');
        }
        var handlers = collection.get(name);
        if (handlers === undefined) {
            collection.set(name, [{ paramsType: paramsType, fn: impl }]);
        }
        else {
            handlers.push({ paramsType: paramsType, fn: impl });
        }
    };
    TypesafeRequestDispatcher.prototype.method = function (name, paramsType, impl) {
        TypesafeRequestDispatcher.register(this.requestHandlers, name, paramsType, impl);
        return this;
    };
    TypesafeRequestDispatcher.prototype.notification = function (name, paramsType, impl) {
        TypesafeRequestDispatcher.register(this.notificationHandlers, name, paramsType, impl);
        return this;
    };
    return TypesafeRequestDispatcher;
}());
export default TypesafeRequestDispatcher;
