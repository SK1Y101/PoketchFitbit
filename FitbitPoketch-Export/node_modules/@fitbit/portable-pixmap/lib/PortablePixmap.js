"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PPMParseError = void 0;
var tslib_1 = require("tslib");
var error_subclass_1 = tslib_1.__importDefault(require("error-subclass"));
// The PPM format does not place a limit on the size of the header, but
// we will do so for convenience of parsing. This is very unlikely to be
// exceeded unless someone's doing something exotic with comments.
var MAX_HEADER_LENGTH = 4096;
var PPMParseError = /** @class */ (function (_super) {
    tslib_1.__extends(PPMParseError, _super);
    function PPMParseError() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    PPMParseError.displayName = 'PPMParseError';
    return PPMParseError;
}(error_subclass_1.default));
exports.PPMParseError = PPMParseError;
/**
 * Parses a numeric header field, handling embedded comments.
 *
 * @param {string} field - the raw lexed field string
 * @returns {number} - the parsed number encoded in the field
 */
function parseHeaderField(field) {
    return parseInt(field.replace(/#.*[\r\n]/g, ''), 10);
}
/**
 * Netpbm PPM color image format.
 *
 * http://netpbm.sourceforge.net/doc/ppm.html
 */
var PortablePixmap = /** @class */ (function () {
    /**
     * Construct a PPM instance directly in memory.
     */
    function PortablePixmap(width, height, maxval, data) {
        this.width = width;
        this.height = height;
        this.maxval = maxval;
        this.data = data;
    }
    /**
     * Convert the image data to an RGBA8888 raster, suitable for input to
     * an HTML5 Canvas API ImageData object.
     *
     * @param destination existing array to write into
     */
    PortablePixmap.prototype.toRGBA8888 = function (destination) {
        var pixels = this.width * this.height;
        var buffer = destination || new Uint8ClampedArray(pixels * 4);
        if (buffer.length < pixels * 4) {
            throw new Error('Destination array too small');
        }
        if (this.maxval < 256) {
            for (var i = 0; i < pixels; i += 1) {
                buffer[i * 4] = (this.data[i * 3] * 255) / this.maxval;
                buffer[i * 4 + 1] = (this.data[i * 3 + 1] * 255) / this.maxval;
                buffer[i * 4 + 2] = (this.data[i * 3 + 2] * 255) / this.maxval;
                buffer[i * 4 + 3] = 255; // Alpha
            }
        }
        else {
            for (var i = 0; i < pixels; i += 1) {
                buffer[i * 4] = (this.data.readUInt16BE(i * 6) * 255) / this.maxval;
                buffer[i * 4 + 1] =
                    (this.data.readUInt16BE(i * 6 + 2) * 255) / this.maxval;
                buffer[i * 4 + 2] =
                    (this.data.readUInt16BE(i * 6 + 4) * 255) / this.maxval;
                buffer[i * 4 + 3] = 255; // Alpha
            }
        }
        return buffer;
    };
    /**
     * Parse PPM (Netpbm color image) format data.
     *
     * The pixel raster data in the constructed image is a slice of the
     * input buffer, so mutating the buffer will also mutate the image.
     *
     * @param buffer buffer of PPM-format image data
     */
    PortablePixmap.parse = function (buffer) {
        // Comments in the header are weird:
        //   Before the whitespace character that delimits the raster, any
        //   characters from a "#" through the next carriage return or newline
        //   character, is a comment and is ignored. Note that this is rather
        //   unconventional, because a comment can actually be in the middle
        //   of what you might consider a token. Note also that this means if
        //   you have a comment right before the raster, the newline at the
        //   end of the comment is not sufficient to delimit the raster.
        var lexer = {
            magic: /P6(?:\s|#.*[\r\n])*\s/y,
            dimension: /(?:\s|#.*[\r\n])*(\d(?:\d|#.*[\r\n])*)\s+/y,
            maxval: /(?:\s|#.*[\r\n])*(\d(?:\d|#.*[\r\n])*)[\r\n]/y,
        };
        var header = buffer.toString('binary', 0, MAX_HEADER_LENGTH);
        if (!lexer.magic.test(header)) {
            throw new PPMParseError('bad magic');
        }
        lexer.dimension.lastIndex = lexer.magic.lastIndex;
        var widthField = lexer.dimension.exec(header);
        if (widthField === null)
            throw new PPMParseError('malformed width');
        var heightField = lexer.dimension.exec(header);
        if (heightField === null)
            throw new PPMParseError('malformed height');
        lexer.maxval.lastIndex = lexer.dimension.lastIndex;
        var maxvalField = lexer.maxval.exec(header);
        if (maxvalField === null)
            throw new PPMParseError('malformed maxval');
        var width = parseHeaderField(widthField[1]);
        var height = parseHeaderField(heightField[1]);
        var maxval = parseHeaderField(maxvalField[1]);
        if (width === 0)
            throw new PPMParseError('width is zero');
        if (height === 0)
            throw new PPMParseError('height is zero');
        if (maxval <= 0 || maxval >= 65536) {
            throw new PPMParseError("maxval out of range: " + maxval);
        }
        var rasterStart = lexer.maxval.lastIndex;
        var rasterEnd = rasterStart + width * height * 3 * (maxval > 255 ? 2 : 1);
        if (rasterEnd > buffer.length)
            throw new PPMParseError('truncated file');
        return new this(width, height, maxval, buffer.slice(rasterStart, rasterEnd));
    };
    return PortablePixmap;
}());
exports.default = PortablePixmap;
//# sourceMappingURL=PortablePixmap.js.map