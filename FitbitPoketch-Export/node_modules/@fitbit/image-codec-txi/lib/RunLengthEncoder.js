"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function comparePixel(a, b) {
    if (a.length !== b.length)
        return false;
    for (var i = 0; i < a.length; i += 1) {
        if (a[i] !== b[i])
            return false;
    }
    return true;
}
var MAX_SECTION_LENGTH = 127;
var RunLengthEncoder = /** @class */ (function () {
    function RunLengthEncoder(destination, bytesPerPixel) {
        this.destination = destination;
        this.lastPixelValid = false;
        this.pixelCount = 0;
        this.willCompress = false;
        this.headerIndex = this.destination.tell();
        this.lastPixel = new Uint8Array(bytesPerPixel);
    }
    RunLengthEncoder.prototype.writePixelToSection = function () {
        if (this.pixelCount === 0)
            this.destination.seek(this.headerIndex + 1);
        this.destination.writeArray(this.lastPixel);
        this.pixelCount += 1;
    };
    Object.defineProperty(RunLengthEncoder.prototype, "isSectionFull", {
        get: function () {
            return this.pixelCount === MAX_SECTION_LENGTH;
        },
        enumerable: false,
        configurable: true
    });
    RunLengthEncoder.prototype.setLastPixel = function (pixel) {
        this.lastPixel.set(pixel);
        this.lastPixelValid = true;
    };
    RunLengthEncoder.prototype.flush = function () {
        if (!this.willCompress && this.lastPixelValid) {
            this.writePixelToSection();
        }
        return this.internalFlush();
    };
    RunLengthEncoder.prototype.internalFlush = function () {
        if (this.pixelCount > 0) {
            var headerByte = this.willCompress ? MAX_SECTION_LENGTH + 1 : 0;
            headerByte |= this.pixelCount & MAX_SECTION_LENGTH;
            this.destination.array[this.headerIndex] = headerByte;
        }
        this.pixelCount = 0;
        this.headerIndex = this.destination.tell();
    };
    RunLengthEncoder.prototype.encode = function (pixel) {
        if (this.willCompress) {
            if (this.lastPixelValid && comparePixel(pixel, this.lastPixel)) {
                this.pixelCount += 1;
                if (this.isSectionFull) {
                    this.internalFlush();
                    this.willCompress = false;
                    this.lastPixelValid = false;
                }
            }
            else {
                this.internalFlush();
                this.willCompress = false;
                this.setLastPixel(pixel);
            }
        }
        else if (this.lastPixelValid && comparePixel(pixel, this.lastPixel)) {
            this.internalFlush();
            this.willCompress = true;
            this.writePixelToSection();
            this.pixelCount = 2;
        }
        else {
            if (this.lastPixelValid)
                this.writePixelToSection();
            if (this.isSectionFull)
                this.internalFlush();
            this.setLastPixel(pixel);
        }
    };
    return RunLengthEncoder;
}());
exports.default = RunLengthEncoder;
//# sourceMappingURL=RunLengthEncoder.js.map