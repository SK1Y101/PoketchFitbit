"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HostConnection = void 0;
const tslib_1 = require("tslib");
require("stream.finished/auto");
const fdb_debugger_1 = require("@fitbit/fdb-debugger");
const dateformat_1 = tslib_1.__importDefault(require("dateformat"));
const fs_1 = tslib_1.__importDefault(require("fs"));
const stream_1 = tslib_1.__importDefault(require("stream"));
const ts_events_1 = require("ts-events");
const developerRelay = tslib_1.__importStar(require("../api/developerRelay"));
const StreamTap_1 = tslib_1.__importDefault(require("./StreamTap"));
class HostConnection {
    constructor(ws, host) {
        this.ws = ws;
        this.host = host;
    }
    static getDumpStreamTap() {
        const shouldDumpLogFile = process.env.FITBIT_DEVBRIDGE_DUMP === '1';
        if (!shouldDumpLogFile)
            return undefined;
        const dumpLogFilePath = dateformat_1.default('"log" yyyy-mm-dd "at" H.MM.ss."txt"');
        const dumpLogFileHandle = fs_1.default.openSync(dumpLogFilePath, 'w');
        const now = () => new Date().getTime();
        const epoch = now();
        function writeChunk(prefix) {
            return (chunk) => fs_1.default.writeSync(dumpLogFileHandle, `[${prefix}][${now() - epoch}] ${JSON.stringify(chunk, undefined, 2)}\n`);
        }
        const transforms = {
            preSerializeTransform: new StreamTap_1.default(writeChunk('send')),
            postDeserializeTransform: new StreamTap_1.default(writeChunk('recv')),
        };
        stream_1.default.finished(transforms.postDeserializeTransform, () => fs_1.default.closeSync(dumpLogFileHandle));
        return transforms;
    }
    static async connect(hostID) {
        const ws = await developerRelay.connect(hostID);
        return new this(ws, await fdb_debugger_1.RemoteHost.connect(ws, this.getDumpStreamTap()));
    }
}
exports.HostConnection = HostConnection;
class HostConnections {
    constructor() {
        this.onHostAdded = new ts_events_1.SyncEvent();
    }
    async connect(hostType, hostID) {
        const existingHost = this[hostType];
        if (existingHost)
            existingHost.ws.destroy();
        const hostConnection = await HostConnection.connect(hostID);
        this[hostType] = hostConnection;
        this.onHostAdded.post({ hostType, host: hostConnection.host });
        return hostConnection;
    }
}
exports.default = HostConnections;
//# sourceMappingURL=HostConnections.js.map