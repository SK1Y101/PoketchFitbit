"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.assertCompanionComponentIsCompatible = exports.findCompatibleAppComponent = void 0;
const tslib_1 = require("tslib");
const error_subclass_1 = tslib_1.__importDefault(require("error-subclass"));
const humanize_list_1 = tslib_1.__importDefault(require("humanize-list"));
const lodash_1 = tslib_1.__importDefault(require("lodash"));
const semver_1 = tslib_1.__importDefault(require("semver"));
class CompatibilityError extends error_subclass_1.default {
}
CompatibilityError.displayName = 'CompatibilityError';
class AppCompatibilityError extends CompatibilityError {
    constructor() {
        super(...arguments);
        this.component = 'app';
    }
}
AppCompatibilityError.displayName = 'AppCompatibilityError';
class CompanionCompatibilityError extends CompatibilityError {
    constructor() {
        super(...arguments);
        this.component = 'companion';
    }
}
CompanionCompatibilityError.displayName = 'CompanionCompatibilityError';
function isAPICompatible(apiVersion, compatibilityDescriptor) {
    if (apiVersion === '*')
        return true;
    const { maxAPIVersion, exactAPIVersion } = Object.assign({ maxAPIVersion: '1.0.0' }, compatibilityDescriptor);
    const apiVersionRange = `>=${semver_1.default.major(apiVersion)}.${semver_1.default.minor(apiVersion)}.0`;
    return (semver_1.default.satisfies(maxAPIVersion, apiVersionRange) ||
        ((exactAPIVersion || []).some(v => semver_1.default.eq(v, apiVersion))));
}
function getAppHostCompatibilityMatrix(hostInfo) {
    let descriptors = lodash_1.default.get(hostInfo, 'capabilities.appHost.install.appCompatibility');
    if (!descriptors) {
        const parsedDevice = /^(Higgs) (27\.31\.\d+\.\d+)$/.exec(hostInfo.device);
        if (parsedDevice) {
            descriptors = [{
                    family: parsedDevice[1],
                    version: parsedDevice[2],
                }];
        }
    }
    return (descriptors || []).map((descriptor) => (Object.assign(Object.assign({}, descriptor), { family: descriptor.family.toLowerCase() })));
}
function findCompatibleAppComponent(appPackage, hostInfo, platformNameTransformer = (s) => s) {
    const hostCompatibility = getAppHostCompatibilityMatrix(hostInfo);
    const builtPlatforms = new Set(Object.keys(appPackage.components.device));
    const runtimePlatforms = new Set(Object.values(hostCompatibility).map((spec) => spec.family));
    const platformNames = (platforms) => humanize_list_1.default([...platforms].map(platformNameTransformer));
    const matchedPlatforms = new Set([...runtimePlatforms].filter(x => builtPlatforms.has(x)));
    if (matchedPlatforms.size === 0) {
        throw new AppCompatibilityError(`App was built for ${platformNames(builtPlatforms)}, but connected device only supports ${platformNames(runtimePlatforms)} applications.`);
    }
    for (const hostCompatibilityDescriptor of hostCompatibility) {
        const { family } = hostCompatibilityDescriptor;
        if (!matchedPlatforms.has(family))
            continue;
        if (!isAPICompatible(appPackage.sdkVersion.deviceApi, hostCompatibilityDescriptor))
            continue;
        return family;
    }
    throw new AppCompatibilityError('Connected device does not support API version requested by app.');
}
exports.findCompatibleAppComponent = findCompatibleAppComponent;
function getCompanionHostCompatibilityMatrix(hostInfo) {
    return lodash_1.default.get(hostInfo, 'capabilities.appHost.install.companionCompatibility');
}
function assertCompanionComponentIsCompatible(appPackage, hostInfo) {
    const hostCompatibilityDescriptor = getCompanionHostCompatibilityMatrix(hostInfo);
    if (!isAPICompatible(appPackage.sdkVersion.companionApi, hostCompatibilityDescriptor)) {
        throw new CompanionCompatibilityError('Connected phone does not support API version specified requested by companion.');
    }
}
exports.assertCompanionComponentIsCompatible = assertCompanionComponentIsCompatible;
//# sourceMappingURL=compatibility.js.map