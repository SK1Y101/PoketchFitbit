"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sourceMapMessage = exports.transformPosition = exports.appURItoPOSIXPath = void 0;
const tslib_1 = require("tslib");
const path_1 = tslib_1.__importDefault(require("path"));
function appURItoPOSIXPath(uri) {
    const normalized = path_1.default.posix.normalize(uri.replace('app://', ''));
    return normalized[0] === '/' ? normalized.substring(1) : normalized;
}
exports.appURItoPOSIXPath = appURItoPOSIXPath;
function transformPosition(position, sourceMaps) {
    position.source = appURItoPOSIXPath(position.source);
    if (position.generated || !sourceMaps)
        return position;
    const sourceMapConsumer = sourceMaps[position.source];
    if (!sourceMapConsumer)
        return position;
    const mappedPosition = sourceMapConsumer.originalPositionFor({
        line: position.line + 1,
        column: position.column,
    });
    if (mappedPosition.line === null || mappedPosition.column === null)
        return position;
    mappedPosition.line -= 1;
    return {
        line: mappedPosition.line,
        column: mappedPosition.column,
        name: mappedPosition.name || position.name,
        source: mappedPosition.source || position.source,
    };
}
exports.transformPosition = transformPosition;
function sourceMapMessage(message, sourceMaps) {
    if ('position' in message && message.position) {
        message.position = transformPosition(message.position, sourceMaps[message.emittedBy.component]);
    }
    if ('stack' in message) {
        message.stack = message.stack.map((position) => {
            return transformPosition(position, sourceMaps[message.emittedBy.component]);
        });
    }
    return message;
}
exports.sourceMapMessage = sourceMapMessage;
//# sourceMappingURL=sourceMapUtil.js.map