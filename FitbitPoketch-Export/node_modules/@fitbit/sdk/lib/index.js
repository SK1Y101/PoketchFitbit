"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.build = exports.buildProject = exports.buildAppPackage = exports.buildCompanion = exports.buildDeviceComponents = exports.buildDeviceResources = exports.buildComponent = exports.loadProjectConfig = exports.generateBuildId = exports.DiagnosticCategory = void 0;
const tslib_1 = require("tslib");
const fs_1 = tslib_1.__importDefault(require("fs"));
const stream_1 = require("stream");
const drop_stream_1 = tslib_1.__importDefault(require("drop-stream"));
const lazystream_1 = tslib_1.__importDefault(require("lazystream"));
const multistream_1 = tslib_1.__importDefault(require("multistream"));
const multipipe_1 = tslib_1.__importDefault(require("multipipe"));
const playback_stream_1 = tslib_1.__importDefault(require("playback-stream"));
const plugin_error_1 = tslib_1.__importDefault(require("plugin-error"));
const simple_random_1 = tslib_1.__importDefault(require("simple-random"));
const vinyl_fs_1 = tslib_1.__importDefault(require("vinyl-fs"));
const appPackageManifest_1 = tslib_1.__importDefault(require("./appPackageManifest"));
const BuildError_1 = tslib_1.__importDefault(require("./util/BuildError"));
const buildTargets_1 = tslib_1.__importDefault(require("./buildTargets"));
const collectComponentSourceMaps_1 = tslib_1.__importDefault(require("./collectComponentSourceMaps"));
const compile_1 = tslib_1.__importDefault(require("./compile"));
const compileTranslations_1 = tslib_1.__importDefault(require("./compileTranslations"));
const componentManifest_1 = require("./componentManifest");
const componentTargets_1 = tslib_1.__importStar(require("./componentTargets"));
const convertImageToTXI_1 = tslib_1.__importStar(require("./convertImageToTXI"));
const eventsIntercept_1 = tslib_1.__importDefault(require("./util/eventsIntercept"));
const gulpAssertFiles_1 = tslib_1.__importDefault(require("./gulpAssertFiles"));
const gulpSetProperty_1 = tslib_1.__importDefault(require("./gulpSetProperty"));
const diagnostics_1 = require("./diagnostics");
Object.defineProperty(exports, "DiagnosticCategory", { enumerable: true, get: function () { return diagnostics_1.DiagnosticCategory; } });
const filterResourceTag_1 = tslib_1.__importDefault(require("./filterResourceTag"));
const findEntryPoint_1 = tslib_1.__importDefault(require("./findEntryPoint"));
const mergeStream_1 = tslib_1.__importDefault(require("./mergeStream"));
const nativeComponents_1 = tslib_1.__importDefault(require("./nativeComponents"));
const pluginError_1 = tslib_1.__importDefault(require("./util/pluginError"));
const ProjectConfiguration_1 = require("./ProjectConfiguration");
const resources = tslib_1.__importStar(require("./resources"));
const validateIcon_1 = tslib_1.__importDefault(require("./validateIcon"));
const validateFileSizes_1 = tslib_1.__importDefault(require("./validateFileSizes"));
const zip_1 = tslib_1.__importDefault(require("./zip"));
const diagnosticTargets = {
    [componentTargets_1.ComponentType.COMPANION]: diagnostics_1.DiagnosticTarget.Companion,
    [componentTargets_1.ComponentType.SETTINGS]: diagnostics_1.DiagnosticTarget.Settings,
    [componentTargets_1.ComponentType.DEVICE]: diagnostics_1.DiagnosticTarget.App,
};
function generateBuildId() {
    return `0x0${simple_random_1.default({
        secure: simple_random_1.default.isSecureSupported,
        chars: '0123456789abcdef',
        length: 15,
    })}`;
}
exports.generateBuildId = generateBuildId;
function addDiagnosticTarget(target, onDiagnostic) {
    return (diagnostic) => onDiagnostic(Object.assign({ target }, diagnostic));
}
function addErrorTarget(target, fn) {
    function wrap(err) {
        if (BuildError_1.default.is(err) || pluginError_1.default.isPluginError(err)) {
            err.target = target;
        }
        return err;
    }
    try {
        const buildStream = eventsIntercept_1.default(fn());
        buildStream.intercept('error', (err, done) => done(null, wrap(err)));
        return buildStream;
    }
    catch (ex) {
        throw wrap(ex);
    }
}
function lazyObjectReadable(fn) {
    const lazyStream = new lazystream_1.default.Readable(() => {
        try {
            return fn();
        }
        catch (ex) {
            lazyStream.emit('error', ex);
            return emptyReadable();
        }
    }, { objectMode: true });
    return lazyStream;
}
function emptyReadable() {
    return new stream_1.Readable({
        objectMode: true,
        read() {
            this.push(null);
        },
    });
}
function transformIf(condition, plugin) {
    return condition ? plugin : new stream_1.Stream.PassThrough({ objectMode: true });
}
function loadProjectConfig({ hasNativeComponents = false, onDiagnostic = diagnostics_1.logDiagnosticToConsole, fileName = 'package.json', }) {
    try {
        const config = ProjectConfiguration_1.normalizeProjectConfig(JSON.parse(fs_1.default.readFileSync(fileName, 'utf-8')));
        const diagnostics = ProjectConfiguration_1.validate(config, { hasNativeComponents });
        diagnostics.diagnostics.forEach((diagnostic) => onDiagnostic(Object.assign({ file: { path: fileName } }, diagnostic)));
        if (diagnostics.fatalError) {
            throw new BuildError_1.default('Project configuration is invalid');
        }
        if (config.enableProposedAPI) {
            onDiagnostic({
                category: diagnostics_1.DiagnosticCategory.Warning,
                messageText: 'Targeting proposed API may cause your app to behave unexpectedly. Use only when needed for development or QA.',
            });
        }
        return config;
    }
    catch (err) {
        throw new plugin_error_1.default('projectConfig', err, { fileName });
    }
}
exports.loadProjectConfig = loadProjectConfig;
function buildComponent({ projectConfig, component, onDiagnostic = diagnostics_1.logDiagnosticToConsole, }) {
    const { inputs, outputDir, notFoundIsFatal } = componentTargets_1.default[component];
    const entryPoint = findEntryPoint_1.default(inputs, {
        onDiagnostic,
        component,
        notFoundIsFatal,
    });
    if (!entryPoint)
        return;
    return lazyObjectReadable(() => multipipe_1.default([
        compile_1.default({
            component,
            onDiagnostic,
            entryPoint,
            outputDir,
            allowUnknownExternals: projectConfig.enableProposedAPI,
            defaultLanguage: projectConfig.defaultLanguage,
        }),
        gulpSetProperty_1.default({
            componentType: component,
        }),
    ]));
}
exports.buildComponent = buildComponent;
function buildDeviceResources(projectConfig, { resourceFilterTag }, onDiagnostic = diagnostics_1.logDiagnosticToConsole) {
    return multipipe_1.default([
        vinyl_fs_1.default.src('./resources/**', { base: '.' }),
        filterResourceTag_1.default(resourceFilterTag),
        validateIcon_1.default({ projectConfig, onDiagnostic }),
        convertImageToTXI_1.default({
            rgbaOutputFormat: convertImageToTXI_1.TXIOutputFormat.RGBA6666,
        }),
        gulpAssertFiles_1.default([resources.svgMain, resources.svgWidgets]),
    ]);
}
exports.buildDeviceResources = buildDeviceResources;
function buildDeviceComponents({ projectConfig, buildId, onDiagnostic = diagnostics_1.logDiagnosticToConsole, }) {
    const deviceJSPipeline = [
        buildComponent({
            projectConfig,
            onDiagnostic,
            component: componentTargets_1.ComponentType.DEVICE,
        }),
    ];
    const processedJS = new playback_stream_1.default({ objectMode: true });
    deviceJSPipeline.push(processedJS);
    return multistream_1.default.obj([
        multipipe_1.default([
            ...deviceJSPipeline,
            drop_stream_1.default.obj(),
        ]),
        ...projectConfig.buildTargets.map((family) => lazyObjectReadable(() => {
            const { platform, displayName, maxDeviceBundleSize } = buildTargets_1.default[family];
            onDiagnostic({
                messageText: `Building app for ${displayName}`,
                category: diagnostics_1.DiagnosticCategory.Message,
            });
            const bundleFilename = `device-${family}.zip`;
            const sourceMap = collectComponentSourceMaps_1.default();
            return multipipe_1.default([
                mergeStream_1.default(...[
                    multipipe_1.default([
                        processedJS.newReadableSide({ objectMode: true }),
                        sourceMap.collector(componentTargets_1.ComponentType.DEVICE, family),
                    ]),
                    projectConfig.appType === ProjectConfiguration_1.AppType.SERVICE
                        ? undefined
                        : buildDeviceResources(projectConfig, buildTargets_1.default[family], onDiagnostic),
                    multipipe_1.default([
                        vinyl_fs_1.default.src(componentTargets_1.default.device.translationsGlob, {
                            base: '.',
                        }),
                        compileTranslations_1.default(projectConfig.defaultLanguage),
                    ]),
                ].filter(Boolean)),
                componentManifest_1.makeDeviceManifest({ projectConfig, buildId, targetDevice: family }),
                zip_1.default(bundleFilename),
                transformIf(maxDeviceBundleSize !== undefined, validateFileSizes_1.default({
                    onDiagnostic,
                    maxSizes: { [bundleFilename]: maxDeviceBundleSize },
                })),
                gulpSetProperty_1.default({
                    componentBundle: {
                        family,
                        platform,
                        type: 'device',
                    },
                }),
                sourceMap.emitter,
            ]);
        })),
    ]);
}
exports.buildDeviceComponents = buildDeviceComponents;
function buildCompanion({ projectConfig, buildId, onDiagnostic = diagnostics_1.logDiagnosticToConsole, }) {
    const sourceMaps = collectComponentSourceMaps_1.default();
    const [companion, settings] = [
        componentTargets_1.ComponentType.COMPANION,
        componentTargets_1.ComponentType.SETTINGS,
    ].map((componentType) => {
        const targetedDiagnostic = addDiagnosticTarget(diagnosticTargets[componentType], onDiagnostic);
        const component = buildComponent({
            projectConfig,
            component: componentType,
            onDiagnostic: targetedDiagnostic,
        });
        if (component) {
            return lazyObjectReadable(() => {
                targetedDiagnostic({
                    category: diagnostics_1.DiagnosticCategory.Message,
                    messageText: `Building ${diagnosticTargets[componentType]}`,
                });
                return multipipe_1.default([
                    addErrorTarget(diagnosticTargets[componentType], () => component),
                    sourceMaps.collector(componentType),
                ]);
            });
        }
        return component;
    });
    if (settings && !companion) {
        throw new BuildError_1.default('This project is being built with settings, but has no companion component.');
    }
    const components = [companion, settings].filter((component) => component !== undefined);
    if (components.length === 0)
        return;
    return lazyObjectReadable(() => multipipe_1.default([
        multistream_1.default.obj(components),
        componentManifest_1.makeCompanionManifest({
            projectConfig,
            buildId,
            hasSettings: !!settings,
        }),
        zip_1.default('companion.zip'),
        gulpSetProperty_1.default({
            componentBundle: { type: 'companion' },
        }),
        sourceMaps.emitter,
    ]));
}
exports.buildCompanion = buildCompanion;
function buildAppPackage({ projectConfig, buildId, existingDeviceComponents, onDiagnostic = diagnostics_1.logDiagnosticToConsole, }) {
    const components = [];
    if (existingDeviceComponents) {
        onDiagnostic({
            messageText: 'Bundling native device components, JS device app will not be built',
            category: diagnostics_1.DiagnosticCategory.Message,
        });
        components.push(existingDeviceComponents);
    }
    else {
        components.push(addErrorTarget(diagnostics_1.DiagnosticTarget.App, () => buildDeviceComponents({
            projectConfig,
            buildId,
            onDiagnostic: addDiagnosticTarget(diagnostics_1.DiagnosticTarget.App, onDiagnostic),
        })));
    }
    const companion = buildCompanion({
        projectConfig,
        buildId,
        onDiagnostic: addDiagnosticTarget(diagnostics_1.DiagnosticTarget.Companion, onDiagnostic),
    });
    if (companion)
        components.push(companion);
    return multipipe_1.default([
        multistream_1.default.obj(components),
        appPackageManifest_1.default({
            projectConfig,
            buildId,
        }),
        zip_1.default('app.fba'),
    ]);
}
exports.buildAppPackage = buildAppPackage;
function buildProject({ nativeDeviceComponentPaths = [], onDiagnostic = diagnostics_1.logDiagnosticToConsole, }) {
    let buildId;
    let existingDeviceComponents;
    const projectConfig = loadProjectConfig({
        onDiagnostic,
        hasNativeComponents: nativeDeviceComponentPaths && nativeDeviceComponentPaths.length > 0,
    });
    if (nativeDeviceComponentPaths.length > 0) {
        ({ buildId, existingDeviceComponents } = nativeComponents_1.default(projectConfig.appUUID, nativeDeviceComponentPaths));
    }
    else {
        buildId = generateBuildId();
    }
    return buildAppPackage({
        projectConfig,
        buildId,
        onDiagnostic,
        existingDeviceComponents,
    }).on('finish', () => {
        onDiagnostic({
            messageText: `App UUID: ${projectConfig.appUUID}, BuildID: ${buildId}`,
            category: diagnostics_1.DiagnosticCategory.Message,
        });
    });
}
exports.buildProject = buildProject;
function build({ dest = vinyl_fs_1.default.dest('./build'), onDiagnostic = diagnostics_1.logDiagnosticToConsole, nativeDeviceComponentPaths, } = {}) {
    return new Promise((resolve, reject) => {
        function wrapBuildErrors(e) {
            if (e === undefined) {
                resolve();
                return;
            }
            if (pluginError_1.default.isPluginError(e) && pluginError_1.default.isProjectBuildError(e)) {
                onDiagnostic(pluginError_1.default.convertToDiagnostic(e));
                return reject();
            }
            if (BuildError_1.default.is(e)) {
                onDiagnostic(e.toDiagnostic());
                return reject();
            }
            return reject(e);
        }
        try {
            multipipe_1.default([buildProject({ nativeDeviceComponentPaths, onDiagnostic }), dest], wrapBuildErrors);
        }
        catch (e) {
            wrapBuildErrors(e);
        }
    });
}
exports.build = build;
