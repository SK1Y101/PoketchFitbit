"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = require("path");
const diagnostics_1 = require("./diagnostics");
const defaultCodeCategories = {
    EMPTY_BUNDLE: diagnostics_1.DiagnosticCategory.Error,
    MISSING_EXPORT: diagnostics_1.DiagnosticCategory.Error,
    NAMESPACE_CONFLICT: diagnostics_1.DiagnosticCategory.Error,
    THIS_IS_UNDEFINED: false,
    UNRESOLVED_IMPORT: diagnostics_1.DiagnosticCategory.Error,
};
const messageFormatter = {
    UNRESOLVED_IMPORT: (w) => `${w.source} is imported by ${w.importer}, but could not be resolved`,
};
function relativeId(id) {
    if (typeof process === 'undefined' ||
        !/^(?:\/|(?:[A-Za-z]:)?[\\|/])/.test(id)) {
        return id;
    }
    return path_1.relative(process.cwd(), id);
}
function defaultFormatter(w) {
    return w.loc && w.loc.file
        ? `${relativeId(w.loc.file)} (${w.loc.line}:${w.loc.column}) ${w.message}`
        : w.message;
}
const rollupWarningToDiagnostic = (codeCategories) => (warning) => {
    if (typeof warning === 'string') {
        return {
            category: diagnostics_1.DiagnosticCategory.Warning,
            messageText: warning,
        };
    }
    const { code } = warning;
    let category = diagnostics_1.DiagnosticCategory.Warning;
    if (code) {
        const codeCategory = codeCategories[code];
        if (codeCategory === false) {
            return;
        }
        if (codeCategory !== undefined)
            category = codeCategory;
    }
    let formatter = defaultFormatter;
    if (code && messageFormatter[code])
        formatter = messageFormatter[code];
    let messageText = formatter(warning);
    if (warning.frame) {
        const context = {
            messageText: warning.frame,
            category: diagnostics_1.DiagnosticCategory.Message,
        };
        messageText = [{ messageText, category }, context];
    }
    return { messageText, category };
};
function rollupWarningHandler({ codeCategories = {}, onDiagnostic = diagnostics_1.logDiagnosticToConsole, }) {
    const toDiagnostic = rollupWarningToDiagnostic(Object.assign(Object.assign({}, defaultCodeCategories), codeCategories));
    return (w) => {
        const diagnostic = toDiagnostic(w);
        if (!diagnostic)
            return;
        onDiagnostic(diagnostic);
        if (diagnostic.category === diagnostics_1.DiagnosticCategory.Error) {
            throw new Error('Compile failed.');
        }
    };
}
exports.default = rollupWarningHandler;
