"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const path_1 = tslib_1.__importDefault(require("path"));
const stream_1 = require("stream");
const t = tslib_1.__importStar(require("io-ts"));
const PathReporter_1 = require("io-ts/lib/PathReporter");
const pipeable_1 = require("fp-ts/lib/pipeable");
const Either_1 = require("fp-ts/lib/Either");
const lodash_1 = tslib_1.__importDefault(require("lodash"));
const plugin_error_1 = tslib_1.__importDefault(require("plugin-error"));
const vinyl_1 = tslib_1.__importDefault(require("vinyl"));
const capabilities_1 = require("./capabilities");
const pathUtils_1 = require("./pathUtils");
const sdkVersion_1 = require("./sdkVersion");
const manifestPath = 'manifest.json';
const PLUGIN_NAME = 'appPackageManifest';
const ComponentBundleTag = t.taggedUnion('type', [
    t.intersection([
        t.interface({
            type: t.literal('device'),
            family: t.string,
            platform: t.array(t.string),
        }),
        t.partial({
            isNative: t.literal(true),
        }),
    ]),
    t.type({
        type: t.literal('companion'),
    }),
]);
function getBundleInfo(file) {
    return pipeable_1.pipe(ComponentBundleTag.decode(file.componentBundle), Either_1.fold((errors) => {
        throw new plugin_error_1.default(PLUGIN_NAME, `Unknown bundle component tag: ${PathReporter_1.failure(errors).join('\n')}`, { fileName: file.relative });
    }, (tag) => tag));
}
class AppPackageManifestTransform extends stream_1.Transform {
    constructor(projectConfig, buildID) {
        super({ objectMode: true });
        this.projectConfig = projectConfig;
        this.buildID = buildID;
        this.sourceMaps = {};
        this.components = {};
        this.hasJS = false;
        this.hasNative = false;
    }
    transformComponentBundle(file) {
        const bundleInfo = getBundleInfo(file);
        function throwDuplicateComponent(existingPath) {
            const componentType = bundleInfo.type === 'device'
                ? `${bundleInfo.type}/${bundleInfo.family}`
                : bundleInfo.type;
            throw new plugin_error_1.default(PLUGIN_NAME, `Duplicate ${componentType} component bundles: ${file.relative} / ${existingPath}`);
        }
        if (bundleInfo.type === 'device') {
            if (bundleInfo.isNative)
                this.hasNative = true;
            else
                this.hasJS = true;
            if (this.hasJS && this.hasNative) {
                throw new plugin_error_1.default(PLUGIN_NAME, 'Cannot bundle mixed native/JS device components', { fileName: file.relative });
            }
            if (!this.components.watch)
                this.components.watch = {};
            if (this.components.watch[bundleInfo.family]) {
                throwDuplicateComponent(this.components.watch[bundleInfo.family].filename);
            }
            const supports = capabilities_1.SupportedDeviceCapabilities.create(bundleInfo.family);
            this.components.watch[bundleInfo.family] = Object.assign({ platform: bundleInfo.platform, filename: file.relative }, (this.hasJS && supports && { supports }));
        }
        else {
            if (this.components[bundleInfo.type] !== undefined) {
                throwDuplicateComponent(this.components[bundleInfo.type].filename);
            }
            this.components[bundleInfo.type] = { filename: file.relative };
        }
    }
    _transform(file, _, next) {
        if (file.componentMapKey) {
            lodash_1.default.merge(this.sourceMaps, lodash_1.default.set({}, file.componentMapKey, pathUtils_1.normalizeToPOSIX(file.relative)));
        }
        if (file.componentBundle) {
            try {
                this.transformComponentBundle(file);
            }
            catch (ex) {
                return next(ex);
            }
        }
        return next(undefined, file);
    }
    _flush(callback) {
        const setSDKVersion = (this.components.watch && this.hasJS) || this.components.companion;
        const { deviceApi, companionApi } = sdkVersion_1.apiVersions(this.projectConfig);
        const manifestJSON = JSON.stringify(Object.assign(Object.assign({ buildId: this.buildID, components: this.components, sourceMaps: this.sourceMaps, manifestVersion: 6 }, (setSDKVersion && {
            sdkVersion: Object.assign(Object.assign({}, (this.components.watch && this.hasJS && { deviceApi })), (this.components.companion && { companionApi })),
        })), { requestedPermissions: this.projectConfig.requestedPermissions, appId: this.projectConfig.appUUID }), undefined, 2);
        this.push(new vinyl_1.default({
            contents: Buffer.from(manifestJSON, 'utf8'),
            path: path_1.default.resolve(process.cwd(), manifestPath),
        }));
        callback();
    }
}
function appPackageManifest({ projectConfig, buildId, }) {
    return new AppPackageManifestTransform(projectConfig, buildId);
}
exports.default = appPackageManifest;
