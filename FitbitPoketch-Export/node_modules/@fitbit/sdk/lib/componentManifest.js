"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeCompanionManifest = exports.makeDeviceManifest = void 0;
const tslib_1 = require("tslib");
const stream_1 = require("stream");
const lodash_1 = tslib_1.__importDefault(require("lodash"));
const plugin_error_1 = tslib_1.__importDefault(require("plugin-error"));
const vinyl_1 = tslib_1.__importDefault(require("vinyl"));
const capabilities_1 = require("./capabilities");
const componentTargets_1 = require("./componentTargets");
const pathUtils_1 = require("./pathUtils");
const ProjectConfiguration_1 = require("./ProjectConfiguration");
const resources = tslib_1.__importStar(require("./resources"));
const sdkVersion_1 = require("./sdkVersion");
const PLUGIN_NAME = 'componentManifest';
const manifestPath = 'manifest.json';
function makeCommonManifest({ projectConfig, buildId, apiVersion, }) {
    const manifest = {
        apiVersion,
        buildId,
        bundleDate: new Date().toISOString(),
        uuid: projectConfig.appUUID,
        name: projectConfig.appDisplayName,
        requestedPermissions: projectConfig.requestedPermissions,
    };
    if (projectConfig.appClusterID) {
        manifest.appClusters = [projectConfig.appClusterID];
    }
    if (projectConfig.developerID) {
        manifest.developerProfileId = projectConfig.developerID;
    }
    return manifest;
}
function makeDeviceManifest({ projectConfig, buildId, targetDevice, }) {
    const locales = projectConfig.i18n;
    let entryPoint;
    return new stream_1.Transform({
        objectMode: true,
        transform(file, _, next) {
            const lang = file.translationLanguage;
            if (lang) {
                if (locales[lang] === undefined)
                    locales[lang] = {};
                locales[lang].resources = pathUtils_1.normalizeToPOSIX(file.relative);
            }
            if (file.isEntryPoint) {
                if (file.componentType === componentTargets_1.ComponentType.DEVICE) {
                    if (entryPoint) {
                        return next(new plugin_error_1.default(PLUGIN_NAME, 'Multiple entry points were generated for device, only one is allowed'));
                    }
                    entryPoint = pathUtils_1.normalizeToPOSIX(file.relative);
                }
                else {
                    return next(new plugin_error_1.default(PLUGIN_NAME, `Entry point for unrecognised component found: ${file.componentType}`));
                }
            }
            next(undefined, file);
        },
        flush(done) {
            if (!entryPoint) {
                return done(new plugin_error_1.default(PLUGIN_NAME, 'No entry point was generated for device component'));
            }
            const _a = locales, _b = projectConfig.defaultLanguage, defaultLanguage = _a[_b], otherLocales = tslib_1.__rest(_a, [typeof _b === "symbol" ? _b : _b + ""]);
            const { deviceApi: apiVersion } = sdkVersion_1.apiVersions(projectConfig);
            const supports = capabilities_1.SupportedDeviceCapabilities.create(targetDevice);
            const i18n = lodash_1.default.mapKeys(Object.assign({ [projectConfig.defaultLanguage]: defaultLanguage }, otherLocales), (_, locale) => locale.toLowerCase());
            const manifestBase = Object.assign(Object.assign({ i18n, appManifestVersion: 1, main: entryPoint }, makeCommonManifest({
                projectConfig,
                buildId,
                apiVersion,
            })), (supports && { supports }));
            let manifest;
            switch (projectConfig.appType) {
                case ProjectConfiguration_1.AppType.APP:
                    manifest = Object.assign(Object.assign({ appType: ProjectConfiguration_1.AppType.APP }, manifestBase), { iconFile: projectConfig.iconFile, wipeColor: projectConfig.wipeColor, svgMain: resources.svgMain, svgWidgets: resources.svgWidgets });
                    break;
                case ProjectConfiguration_1.AppType.CLOCKFACE:
                    manifest = Object.assign(Object.assign({ appType: ProjectConfiguration_1.AppType.CLOCKFACE }, manifestBase), { svgMain: resources.svgMain, svgWidgets: resources.svgWidgets });
                    break;
                case ProjectConfiguration_1.AppType.SERVICE:
                    manifest = Object.assign({ appType: ProjectConfiguration_1.AppType.SERVICE }, manifestBase);
                    break;
            }
            done(undefined, new vinyl_1.default({
                cwd: '',
                base: undefined,
                path: manifestPath,
                contents: Buffer.from(JSON.stringify(manifest)),
            }));
        },
    });
}
exports.makeDeviceManifest = makeDeviceManifest;
function makeCompanionManifest({ projectConfig, hasSettings, buildId, }) {
    let companionEntryPoint;
    let settingsEntryPoint;
    return new stream_1.Transform({
        objectMode: true,
        transform(file, _, next) {
            const isEntryPoint = file.isEntryPoint;
            if (isEntryPoint) {
                if (file.componentType === componentTargets_1.ComponentType.COMPANION) {
                    if (companionEntryPoint) {
                        return next(new plugin_error_1.default(PLUGIN_NAME, 'Multiple entry points were generated for companion, only one is allowed'));
                    }
                    companionEntryPoint = pathUtils_1.normalizeToPOSIX(file.relative);
                }
                else if (file.componentType === componentTargets_1.ComponentType.SETTINGS) {
                    if (settingsEntryPoint) {
                        return next(new plugin_error_1.default(PLUGIN_NAME, 'Multiple entry points were generated for settings, only one is allowed'));
                    }
                    settingsEntryPoint = pathUtils_1.normalizeToPOSIX(file.relative);
                }
                else {
                    return next(new plugin_error_1.default(PLUGIN_NAME, `Entry point for unrecognised component found: ${file.componentType}`));
                }
            }
            next(undefined, file);
        },
        flush(done) {
            if (!companionEntryPoint) {
                return done(new plugin_error_1.default(PLUGIN_NAME, 'No entry point was generated for companion component'));
            }
            const manifest = Object.assign({ manifestVersion: 2, companion: { main: companionEntryPoint } }, makeCommonManifest({
                projectConfig,
                buildId,
                apiVersion: sdkVersion_1.apiVersions(projectConfig).companionApi,
            }));
            if (hasSettings) {
                if (!settingsEntryPoint) {
                    return done(new plugin_error_1.default(PLUGIN_NAME, 'No entry point was generated for settings component'));
                }
                manifest.settings = { main: settingsEntryPoint };
            }
            if (projectConfig.companionDefaultWakeInterval) {
                manifest.defaultWakeInterval =
                    projectConfig.companionDefaultWakeInterval;
            }
            done(undefined, new vinyl_1.default({
                cwd: '',
                base: undefined,
                path: manifestPath,
                contents: Buffer.from(JSON.stringify(manifest)),
            }));
        },
    });
}
exports.makeCompanionManifest = makeCompanionManifest;
