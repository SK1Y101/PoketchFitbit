/// <reference types="node" />
import * as t from 'io-ts';
export declare const IOCapabilities: t.PartialC<{
    write: t.BooleanC;
    additionalEncodings: t.ArrayC<t.StringC>;
}>;
export declare type IOCapabilities = t.TypeOf<typeof IOCapabilities>;
export declare const StreamToken: t.UnionC<[t.RefinementC<t.NumberC>, t.StringC]>;
export declare type StreamToken = t.TypeOf<typeof StreamToken>;
export declare const StreamOpenResponse: t.TypeC<{
    stream: t.UnionC<[t.RefinementC<t.NumberC>, t.StringC]>;
}>;
export declare type StreamOpenResponse = t.TypeOf<typeof StreamOpenResponse>;
export declare const StreamCloseParams: t.TypeC<{
    stream: t.UnionC<[t.RefinementC<t.NumberC>, t.StringC]>;
}>;
export declare type StreamCloseParams = t.TypeOf<typeof StreamCloseParams>;
export declare const IOEncoding: t.UnionC<[t.LiteralC<"base64">, t.LiteralC<"none">]>;
export declare type IOEncoding = t.TypeOf<typeof IOEncoding>;
export declare class NodeBufferType extends t.Type<Buffer> {
    readonly _tag: 'NodeBufferType';
    constructor();
}
export declare const NodeBuffer: NodeBufferType;
export declare const IOWriteParams: t.IntersectionC<[t.TypeC<{
    stream: t.UnionC<[t.RefinementC<t.NumberC>, t.StringC]>;
    data: t.UnionC<[t.StringC, NodeBufferType]>;
}>, t.PartialC<{
    encoding: t.UnionC<[t.LiteralC<"base64">, t.LiteralC<"none">]>;
}>]>;
export declare type IOWriteParams = t.TypeOf<typeof IOWriteParams>;
//# sourceMappingURL=BulkData.d.ts.map